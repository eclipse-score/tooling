---
id: Tooling-DR-001
status: "Draft (participation requested)"
owner: Infrastructure Community
---

# Decision Record: Integration Strategy for External Development Tools

## 1. Context / Problem

We use a broad set of tools (formatters, linters, static analyzers, code generators, license/SBOM and security scanners, doc builders) across multiple repositories. Today, tools are invoked via Bazel, IDEs, and CI with varying levels of pinning and caching. We need a standard approach that runs **identically** in CI, local CLI, and IDE/editor integrations, and that fits ISO 26262/ASPICE constraints (version pinning, determinism, long-term retention, offline path).

## 2. Requirements

1. **Version Pinning**: Identical tool versions across CLI/CI/IDE; no hidden network during execution; artifacts hash-pinned.
2. **Config Consistency**: Central baseline config; explicit, reviewable local overrides with drift detection.
3. **Performance**: Fast full and incremental runs; leverage remote cache/execution for heavy, Bazel-config-dependent tools.
4. **Offline & Retention**: Prefetch & store artifacts for ≥10 years; fully offline execution path.
5. **Platforms**: Linux x86_64 and aarch64.
6. **Low Friction**: Minimal per-repo boilerplate; single invocation pattern; easy upgrades.
7. **Maintenance Effort**: Keep the system simple; avoid bespoke per-tool frameworks.

## 3. Options Considered

### 3.1 Bazel Aspects
Graph-aware aspects performing analysis / formatting per target.

Pros:
* runs only on affected targets (others are cached)
  * no manual file selection, runs on targets
  * remote execution possible
* linters run on correct/desired configuration as selected via bazel

Cons:
* Development/maintenenance complexity (limited know-how)
* slow execution in some cases
  * e.g. per-target virtual environments required for python - potentially this is so fast, that it's not relevant!
  * e.g. same file in multiple targets will be analyzed twice. But potentially with different configurations.
* not all tools can be provided this way (e.g. dot). --> Rare use case? Most tools are packagable.
* not all tools can be provided this way, e.g. plantuml is not an aspect?! --> other solution for such use cases
* no IDE integration -> all tools provided via bazel aspects, must also be provided via one of the other methods.

### 3.2 Bazel Multitool
Centrally pinned binaries executed via `bazel run`.

Pros:
* Simple
* Typically compatible to IDE use cases

Cons:
* does not include sharing centralized config
* does not include caching for executing slow tools
* not all tools can be provided this way (e.g. dot). --> Rare use case? Most tools are packagable.
* requires pre-execution setup (e.g. environment, dependencies)

### 3.3 Devcontainer
Canonical container image as the authoritative tool distribution. Another current solution.

Pros:
* straightforward onboarding (well known concept)
* IDE support out of the box

Cons:
* Large images slow on GitHub CI (as slow as bazel?)
* Tools might implicitly use content from the container, which is not an explicit dependency.

### 3.4 Native Host Installs
Rely on developer & CI host environment package managers.

Pros:
* By far fastest invocation, no wrapper overhead.

Cons:
* No version pinning, unenforceable consistency, high drift
* Requires native setup

## 4. Solution
None of the above need to be truly exclusive. We definitely need bazel aspects for slow
tools that benefit from bazel-config-dependent analysis and caching.

We definitely need devcontainer for tools that cannot be provided via bazel. Those tools
need to be native installs or provided via devcontainer, so we favor the devcontainer
approach for those - while allowing native installs.

Bazel multitool fills the gap for people who do not want to use a devcontainer. It's a
viable alternative, but since this is extra effort on score side, we currently cannot
maintain it.

For small and fast CI jobs, we currently need to rely on native installs, as any bazel
or devcontainer invocation is simply too slow (2+ minutes startup).

## 5. Next Steps

- Define each approach more clearly. Define version pinning and config sharing
  approaches. While that sounds as the next level of detail, I'd like to include it into
  this DR!

## Appendix: Tool List

### Bazel-config-dependent & cacheable
*Ideally we provide these via bazel aspects **and** (devcontainer or multitool for IDE support)*

- Compilers (LLVM/Clang/GCC/… via toolchains)
- `clang-tidy`
- `clang-analyzer`

### Independent & fast code analysis (typically pre-commit / IDE / CI)
*Ideally we provide these via devcontainer or multitool*

- `ruff` (python)
- `basedpyright` (python)
- `actionlint` (github actions)
- `yamlfmt`  (yaml)
- `spellcheck` (text)
- `buildifier` (bazel)

### Independent
*Ideally we provide these via devcontainer or multitool*

- IDE language servers: `rust-analyzer`, `clangd`, `starpls`
- `buildifier`, `bazel-compile-commands`
- `curl`, `qemu-system-aarch64`, `sshpass` (??)
- `protoc`
- `gcovr`

### Not natively cacheable in Bazel
*Ideally we provide these via devcontainer or multitool*

- Sphinx (incl. `sphinx-needs`, `PlantUML`, `graphviz` and ~100 more dependencies)
- GraphQL (static code analysis)
- Eclipse Dash (license analysis)

### System dependencies
*These cannot be provided by bazel. We must provide these via devcontainer (or native installs)*

- `bazelisk` / `bazel`
- `git`
- `dot`
