---
id: Tooling-DR-001
status: "Draft (participation requested)"
owner: Infrastructure Community
---

# Decision Record: Integration Strategy for External Development Tools

## 1. Context / Problem

We use a broad set of tools (formatters, linters, static analyzers, code generators, license/SBOM and security scanners, doc builders) across multiple repositories. Today, tools are invoked via Bazel, IDEs, and CI with varying levels of pinning and caching. We need a standard approach that runs **identically** in CI, local CLI, and IDE/editor integrations, and that fits ISO 26262/ASPICE constraints (version pinning, determinism, long-term retention, offline path).

## 2. Requirements

1. **Version Pinning**: Identical tool versions across CLI/CI/IDE; no hidden network during execution; artifacts hash-pinned.
2. **Config Consistency**: Central baseline config; explicit, reviewable local overrides with drift detection.
3. **Performance**: Fast full and incremental runs; leverage remote cache/execution for heavy, Bazel-config-dependent tools.
4. **Offline & Retention**: Prefetch & store artifacts for ≥10 years; fully offline execution path.
5. **Platforms**: Linux x86_64 and aarch64.
6. **Low Friction**: Minimal per-repo boilerplate; single invocation pattern; easy upgrades.
7. **Maintenance Effort**: Keep the system simple; avoid bespoke per-tool frameworks.

## 3. Options Considered

### 3.1 Bazel Aspects
Graph-aware aspects performing analysis / formatting per target.

Pros:
* runs only on affected targets (others are cached)
  * no manual file selection, runs on targets
  * remote execution possible
* linters run on correct/desired configuration as selected via bazel

Cons:
* Development/maintenenance complexity (limited know-how)
* slow execution in rare cases
  * e.g. big targets do not fit bazels caching philosophy
  * e.g., per-target virtual environments for Python; this can be fast enough that it may not be a blocker.
  * e.g., the same file in multiple targets may be analyzed more than once (potentially with different configurations).
* not all tools can be provided this way (e.g., `dot`) — a rare use case; most tools are packagable.
* not all tools can be provided this way (e.g., PlantUML); provide alternative solutions for those cases.
* no IDE integration -> all tools provided via Bazel aspects must also be provided via one of the other methods for editor support.

### 3.2 Bazel Multitool
Centrally pinned binaries executed via `bazel run`.

Pros:
* Simple
* Typically compatible to IDE use cases

Cons:
* does not include sharing centralized config
* does not include caching for executing slow tools
* not all tools can be provided this way (e.g. dot). --> Rare use case? Most tools are packagable.
* requires pre-execution setup (e.g. environment, dependencies)

### 3.3 Devcontainer
Canonical container image as the authoritative tool distribution. Another current solution.

Pros:
* straightforward onboarding (well known concept)
* IDE support out of the box

Cons:
* Large images slow on GitHub CI (as slow as bazel?)
* Tools might implicitly use content from the container, which is not an explicit dependency.

### 3.4 Native Host Installs
Rely on developer & CI host environment package managers.

Pros:
* By far fastest invocation, no wrapper overhead.

Cons:
* No version pinning, unenforceable consistency, high drift
* Requires native setup

## 4. NEW Deep Dives

### 4.1 Bazel Multitool

We've invested enough time and energy into a solution with multitool to state that it is
a viable option. However, it requires significant effort and workarounds for tools that need
to be called directly from the IDE (for example, the Python binary).

We cannot set Bazel commands as executable paths; editor integrations usually expect a direct executable, so a small local wrapper script per repository is required. Examples: `python`, `ruff`, `starpls`, `spellcheck`, `yamlfmt`.

As multitool does not handle tool configuration, an additional solution is required per tool, which adds complexity.

### 4.2 Tool Versioning

For some tools keeping the version exactly the same is less important. Especially
extensions within VS Code typically come with their own bundled binaries. As long as
those are roughly the same version, slight inconsistencies between IDE and CI are
quite acceptable.

Especially in language servers which are only available within the IDE and are not
strictly safety relevant, this is viable.

### 4.3 Native Tools in CI

As using bazel and devcontainer introduces significant overhead, it seems natural to use certain tools natively in CI.
e.g. using the same installation scripts in devcontainers and CI has proven viable in other projects. Or providing a smaller and more dedicated CI image. These approaches will be detailed in a follow-up DR.

More interestingly there are cases where the exact version is less important (python) or
is managed outside bazel anyway (python requirements.txt files). In such cases native
installs have no disadvantages and are significantly easier (development) and faster (runtime).

## 5. Conclusion

* We use bazel aspects for slow tools that benefit from bazel-config-dependent analysis and caching.

* We use devcontainer for the rest.

* Bazel multitool would fill the gap for people who do not want to use a devcontainer. It's a
viable alternative, but since this is significant extra effort on score side, we currently cannot
maintain it.

* Especially for small and fast CI jobs, we use native installs, as any bazel or devcontainer invocation is simply too slow (2+ minutes startup).


## Appendix: Tool List

### Bazel-config-dependent & cacheable
*Ideally we provide these via bazel aspects **and** (devcontainer or multitool for IDE support)*

- Compilers (LLVM/Clang/GCC/… via toolchains)
- `clang-tidy`
- `clang-analyzer`

### Independent & fast code analysis (typically pre-commit / IDE / CI)
*Ideally we provide these via devcontainer or multitool*

- `ruff` (python)
- `basedpyright` (python)
- `actionlint` (github actions)
- `yamlfmt`  (yaml)
- `spellcheck` (text)
- `buildifier` (bazel)

### Independent
*Ideally we provide these via devcontainer or multitool*

- IDE language servers: `rust-analyzer`, `clangd`, `starpls`
- `buildifier`, `bazel-compile-commands`
- `curl`, `qemu-system-aarch64`, `sshpass` (??)
- `protoc`
- `gcovr`

### Not natively cacheable in Bazel
*Ideally we provide these via devcontainer or multitool*

- Sphinx (incl. `sphinx-needs`, `PlantUML`, `graphviz` and ~100 more dependencies)
- GraphQL (static code analysis)
- Eclipse Dash (license analysis)

### System dependencies
*These cannot be provided by bazel. We must provide these via devcontainer (or native installs)*

- `bazelisk` / `bazel`
- `git`
- `dot`
