# Decision Record: How to integrate external tools

Scope: How we integrate external development/support tools (linters, formatters,
analyzers, code generators, license checkers, etc.) into SCORE development.

## Requirements

1) Version Pinning: Tool versions are pinned and identical across CLI, CI, and IDE;
   hashes / versions verified; no unpinned transitive downloads.
2) Config Pinned: All tool configuration files are identical across CLI, CI, and IDE.
3) Performance: Tools install and run sufficiently fast, especially in CI environments.
   Expensive tools leverage (Bazel) caching where feasible.
4) Offline & Retention: Tools can be pre-fetched, e.g. for â‰¥10 years reproducibility or
   offline use.
5) Platforms: Tools support Linux x86_64 and aarch64.
6) Security & Compliance: Tools follow SCORE security & safety policies of score
   process.
7) Low Friction Integration: Extra code per-repository is minimized; shared
   wrappers/macros preferred.
8) Effort: Maintenance effort is minimized for S-CORE.

## Alternatives

### bazel aspects
*Provide tooling via Bazel aspects that traverse targets and apply actions
(lint/format/analyze) based on build graph metadata.*

* Deep integration: incremental & build-graph aware; avoids scanning unrelated files
* Fine-grained per-target deps & (potentially) configs
* Higher complexity & learning curve; authoring / debugging aspects is non-trivial
* Leverages bazel caching for unchanged targets
* Harder to run standalone outside Bazel (IDE integration wrappers needed)
* Supports multiple python versions
* Supports individual dependencies per target
* Supports individual configs per target?

### bazel multitool (current)
*Provides tools in a architecture agnostic way*

* Central registry of pinned tool archives (hashes); easy global upgrades
* Simple uniform CLI (e.g. bazel run //@tools:ruff) -> low per-repo code
* Limited per-target customization (global config)
* Rather simple approach (setup, usability)

### devcontainer
*Provides tools in an isolated docker environment*

* Single image defines pinned versions; matches local IDE & potentially CI
* Easy onboarding (open in container) and multi-arch via multi-platform images
* Heavy image size; slower CI cold starts & updates
* Bazel cache and distributed build concerns

### native
*Use host tools*

* Can only be used in controlled environments.
* Fast startup; no container / Bazel wrapper overhead
* Minimal indirection; tools usable outside build system
* Therefore potentially mostly interesting for quick informal checks

### summary

After writing/reading all of the above, it really sounds like we could do that in a
table as the points basically repeat themselves in each alternative. Let's see...

Legend:
* âŒ Bad
* ğŸ¤” It depends
* âœ… Good
* â“ No idea

| ---             | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| --------------- | --- | --- | --- | --- | --- | --- | --- | --- |
| bazel aspects   | âŒ   | âœ…   | ğŸ¤”   | â“   | â“   | âœ…   | âœ…   | ğŸ¤”   |
| bazel multitool | âœ…   | ğŸ¤”   | ğŸ¤”   | â“   | âœ…   | âœ…   | âœ…   | âœ…   |
| devcontainer    | âœ…   | âœ…   | ğŸ¤”   | âœ…   | âœ…   | ğŸ¤”   | âœ…   | âœ…   |
| native          | ... |
