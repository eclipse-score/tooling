# Decision Record: Integration Strategy for External Development Tools

Status: Draft (participation requested)
Date: 2025-08-20
Owners: Infrastructure Community

## 1. Context / Problem
Multiple categories of external tooling (formatters, linters, license / SBOM scanners,
static analyzers, code generators, security scanners) are needed across SCORE
repositories. Today we mainly use Bazel multitool; Bazel aspects are emerging; some advocate for devcontainers. None individually optimize for all CI + local needs.

We need a standard approach that scales to additional tools and runs identically in:
CI, local CLI, and IDE/editor integrations.

## 2. Requirements
1. Version Pinning: Identical versions across CLI / CI / IDE; no hidden network fetches during execution (all artifacts hash-pinned).
2. Config Consistency: Central baseline config; local overrides allowed but must be explicit & reviewable (goal: detect drift automatically).
3. Performance: Fast full run & incremental run.
4. Offline & Retention: Prefetch & store artifacts â‰¥10 years; fully offline execution path (no network except initial mirror sync).
5. Platforms: Linux x86_64 & aarch64.
6. Low Friction Integration: Minimal per-repo boilerplate; single invocation pattern; easy upgrades.
7. Maintenance Effort: The solution should be as simple as possible.

## 3. Options Considered

### 3.1 Bazel Multitool Registry
Central macro + pinned binaries executed via `bazel run`. Current solution.

Pros:
* Simple

Cons:
* does not include sharing centralized config
* does not include caching for slow tools
* not all tools can be provided this way (e.g. dot)

### 3.2 Bazel Aspects
Graph-aware aspects performing analysis / formatting per target. Newly available solution (incubation).

Pros:
* can run only on affected targets

Cons:
* Authoring/debugging complexity
* slow execution in some cases (e.g. per-target virtual environments required for python)
* no proper IDE integration?
* not all tools can be provided this way, e.g. plantuml is not an aspect?!

### 3.3 Devcontainer
Canonical container image as the authoritative tool distribution. Another current solution.

Pros:
* straightforward onboarding (well known concept, unlike bazel solutions)

Cons:
* Large images slow on GitHub CI (can we cache them??)
* Container updates require their own logic. Worst case different development branches need different container versions.

### 3.4 Native Host Installs
Rely on developer & CI host environment package managers.

Pros:
* Fastest invocation, no wrapper overhead.

Cons:
* Unenforceable consistency, high drift

### 3.5 Hybrid Solution
None of the above need to be truly exclusive.

Pros: Use the simplest viable primitive per tool class; preserve uniform interface for most tools; enable deeper graph-aware optimization only where measurable benefit (e.g., Python dependency analysis, multi-version lint). Devcontainer becomes a generated convenience layer referencing canonical Bazel definitions.
Cons: Two mental models (simple run vs aspect run) to document; requires generation tooling to prevent duplication; still need retention/mirroring design.

## 4. Evaluation Matrix
Legend: âœ… meets / strong; ğŸ¤” mixed / conditional; âŒ weak; â“ unknown (needs spike)

| Option             | 1 (Pin) | 2 (Config) | 3 (Perf) | 4 (Offline) | 5 (Plat) | 6 (Sec) | 7 (Friction) | 8 (Maint) |
| ------------------ | ------- | --------- | -------- | ----------- | -------- | ------- | ------------ | --------- |
| Bazel Aspects      | âœ… | âœ… | ğŸ¤” (cache dep) | â“ | â“ | âœ… | ğŸ¤” | ğŸ¤” (authoring cost) |
| Bazel Multitool    | âœ… | ğŸ¤” (global cfg) | ğŸ¤” | â“ | âœ… | âœ… | âœ… | âœ… |
| Devcontainer Only  | âœ… | âœ… | ğŸ¤” (image pull) | âœ… | âœ… | ğŸ¤” (base chain) | âœ… | âœ… |
| Native Host        | âŒ | ğŸ¤” | âœ… | âŒ | ğŸ¤” | âŒ | âŒ | âŒ |
| Hybrid Layer (3.5) | âœ… | âœ… (override path) | âœ… (choose best mech) | ğŸ¤” (need mirror) | âœ… | âœ… | âœ… | âœ… |

Notes:
* (3) Performance: Hybrid allows aspects only where they materially reduce runtime (e.g., incremental on changed targets) while keeping trivial tools fast via direct invocation.
* (4) Offline: Mirror strategy (artifact store / OCI + metadata lock) still to be implemented for any option; container-only slightly ahead due to image snapshot capability.
* (2) Config: Hybrid defines layering: baseline central config -> optional repo override -> (future) per-target aspect refinement if justified.
